# 문제 해석
정수 배열의 숫자가 감소하지 않는 순서로 정렬되어 있을 때, 각 고유 요소가 **최대 두 번만 나타나도록** 중복된 부분을 제자리에서 제거합니다. 요소의 상대적 순서는 동일하게 유지해야 합니다.
​
일부 언어에서는 배열의 길이를 변경할 수 없으므로 대신 결과를 배열 nums의 **첫 번째 부분**에 배치해야 합니다. 좀 더 공식적으로 말하자면, 중복을 제거한 후 요소가 k개 있는 경우 nums의 처음 k개 요소가 최종 결과를 보유해야 합니다. 첫 번째 k 요소 너머에 무엇이 남는지는 중요하지 않습니다.
​
최종 결과를 숫자의 첫 번째 k 슬롯에 배치한 후 k를 반환합니다.
​
다른 배열에 추가 공간을 할당하지 마세요. 입력 배열을 수정하여 O(1)의 추가 메모리로 제자리에서 수정해야 합니다.
​
# 접근 방법
처음에는 같은 값이 나올 때마다 counter를 이용해서 3번 이상 증가되면 다음 배열로 진행하는 식으로 접근하려고 했지만 구현하지 못하였다. 그래서 생각해본게 고정된 첫번째 배열 값과 1씩 증가하여 다음 배열의 값을 찾는 비교 연산자가 필요하다. 두 개의 인덱스 값을 서로 감산하여 1을 넘지 않는지 확인한다. 1이 넘는다는 건 같은 값이 2번 이상 나왔다는 것이다. 2번 이상 나오지 않고 고정된 값과 증가된 값의 배열의 값이 같으면 k번째에 증가된 배열의 값을 삽입한다.
# 의사 코드
```
반환할 값 = 0;
고정되는 값 = 0;
증가되는 값 = 0;
​
반복 (증가되는 값이 배열의 크기만큼) {
if (고정된 인덱스의 값과 증가되는 인덱스의 값이 같지 않으면) {
고정된 값 인덱스 = 증가되는 값 인덱스 -> 중복되는 값이 아니라는 뜻
}
if (고정된 값 - 증가된 값 <= 1 && 같은 배열의 값) {
배열[반환할 값 ++] = 배열[현재 위치의 값];
}
움직이는 값++;
}
```
# 문제 해결
```java