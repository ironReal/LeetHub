
​# 2. 문제 해석

피크 요소는 이웃 요소보다 엄격하게 큰 요소입니다.

인덱스가 **0인 정수** 배열의 개수가 주어졌을 때, 피크 요소를 구하고 그 인덱스를 반환합니다. 배열에 여러 개의 피크가 포함되어 있으면 **그 중 하나의 피크**에 대한 인덱스를 반환합니다.

`nums[-1] = nums[n] = -∞`라고 상상할 수 있습니다. 즉, 한 요소는 항상 배열 외부에 있는 이웃 요소보다 엄격하게 큰 것으로 간주됩니다.

`O(log n)` 시간 내에 실행되는 알고리즘을 작성해야 합니다.

## 2. Example
**Example 1:**

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3은 피크 요소이고 함수는 인덱스 번호 2를 반환해야 합니다.

**Example 2:**

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: 함수는 피크 요소가 2인 경우 인덱스 번호 1을 반환하거나 피크 요소가 6인 경우 인덱스 번호 5를 반환할 수 있습니다.

# 3. 문제 접근
`mid` 요소와 `mid + 1` 요소를 확인하려고 한다.
만약 배열[mid] < 배열[mid+1]이라면 왼쪽 값은 중간값 + 1이 될것이고(`low = mid + 1`) 그렇지 않으면 오른쪽 값은 중간값이 될것이다. (`high = mid`)
그 이유는 원소의 개수가 짝수이거나 홀수일 때, 중간 원소는 항상 mid + 1의 다음 원소를 가지게 되기 떄문이다.
더 큰 첫 번째 경의 중간 요소의 + 1 요소로 이동하므로 항상 해가 되므로 왼쪽 값을 반환한다.

# 4. 의사코드
```
배열의 첫번째 요소에서 시작할 왼쪽 값 선언;
배열의 마지막 요소부터 작아지는 오른쪽 값 선언;

while (왼쪽 값 < 오른쪽 값) {
		중간 값 = 왼쪽 값 + (오른쪽 값 - 왼쪽 값) / 2;
		if (배열 중간값 요소보다 다음 요소가 크다면) {
				왼쪽 값 = 중간값의 다음 요소 인덱스 번호;
		} else {
				오른쪽 값 = 중간값;
		}
}

왼쪽 값 반환;
```

# 문제 풀이
```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

				// 왼쪽 값이 오른쪽 값과 만나거나 커질때까지
        while (left < right) {
						// 중간 인덱스 선언
            int mid = left + (right - left) / 2;
						
						// 중간값 요소보다 다음 인덱스 요소가 크다면
            if (nums[mid] < nums[mid + 1]) {
								// 왼쪼 값은 다음 인덱스 요소
                left = mid + 1;
            } else {
								// 오른쪽 값 이동
                right = mid;
            }
        }
        return left;
    }
}
```
<img width="676" alt="image" src="https://github.com/ironReal/LeetHub/assets/46087207/adca9c5a-43bd-4909-94e6-bf27819113b7">

